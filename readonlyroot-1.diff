Index: aaa_base/etc/init.d/boot.rootfsck
===================================================================
--- aaa_base.orig/etc/init.d/boot.rootfsck
+++ aaa_base/etc/init.d/boot.rootfsck
@@ -33,6 +33,13 @@ case "$1" in
 	swapon -ae &> /dev/null
 	rc_status -v1 -r
 	
+	if rc_readonlyroot && test -z "$ROOTFS_FSCK" ; then
+	    echo "Skipping fsck of read-only root filesystem."
+	    # Pretend that the initrd already did a root filesystem check to skip the
+	    # filesystem check we would do below.
+	    ROOTFS_FSCK=0
+	fi
+
 	#
 	# do fsck and start sulogin, if it fails.
 	#
@@ -92,6 +99,8 @@ case "$1" in
 	    mount -n -o remount,ro / 2> /dev/null
 	    if test $? = 0; then
 		if test -n "$ROOTFS_FSCK" ; then
+		    # When the initrd checks the root filesystem, it stores the
+		    # fsck exit status in ROOTFS_FSCK.
 		    FSCK_RETURN=$ROOTFS_FSCK
 		else
 		    echo "Checking root file system..."
@@ -160,10 +169,15 @@ case "$1" in
 		echo "root file system (/) is NOT being checked."
 	    fi
 	fi
-        # start with a clean mtab and enter root fs entry
-	rm -f /etc/mtab* 
-	> /etc/mtab
-	mount -f /
+
+	# If /etc is not writable, mount currently requires that /etc/mtab is a
+	# symlink.  (Else, it will try to create /etc/mtab.$PID and /etc/mtab~.)
+	if test ! -L /etc/mtab ; then
+	    # start with a clean mtab and enter root fs entry
+	    rm -f /etc/mtab*
+	    > /etc/mtab
+	    mount -f /
+	fi
 	;;
     stop)
 	;;
Index: aaa_base/etc/rc.status
===================================================================
--- aaa_base.orig/etc/rc.status
+++ aaa_base/etc/rc.status
@@ -398,3 +398,14 @@ rc_cmdline()
     done
     return 1
 }
+
+rc_readonlyroot()
+{
+    if test -z "${READONLYROOT+x}" ; then
+	if rc_cmdline readonlyroot && ! rc_cmdline noreadonlyroot ; then
+	    READONLYROOT=yes
+	fi > /dev/null
+	export READONLYROOT
+    fi
+    test -n "$READONLYROOT"
+}
